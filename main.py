import time
import requests
from requests.adapters import HTTPAdapter, Retry
from bs4 import BeautifulSoup
from pyrogram import Client, filters
from pyrogram.types import Message
from pyrogram.enums import ParseMode
from difflib import SequenceMatcher

import config
import config_memes as cfg
import buttons
import keyboards
from custom_filters import button_filter

# –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
user_state = {}  # key: user_id, value: {"lang": "en"/"ru", "suggestions": [...]}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ—Å—Å–∏–∏ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
session = requests.Session()
retries = Retry(total=3, backoff_factor=1, status_forcelist=[500,502,503,504])
session.mount('https://', HTTPAdapter(max_retries=retries))
session.mount('http://', HTTPAdapter(max_retries=retries))

# User-Agent
cfg.HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
                  "(KHTML, like Gecko) Chrome/117.0 Safari/537.36"
}

bot = Client(
    name="my_bot",
    api_id=config.API_ID,
    api_hash=config.API_HASH,
    bot_token=config.BOT_TOKEN,
)

# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
def similar(a, b):
    return SequenceMatcher(None, a.lower(), b.lower()).ratio()

def clean_text(block):
    """–£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—Å—ã–ª–∫–∏ –∏ –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç"""
    for a in block.find_all("a"):
        a.replace_with(a.get_text())
    return block.get_text(strip=True)

# === –ü–û–ò–°–ö –ú–ï–ú–û–í ===
def search_kym(query: str):
    try:
        url = cfg.KYM_SEARCH_URL.format(query=query)
        time.sleep(1)
        r = session.get(url, headers=cfg.HEADERS, timeout=20)
        soup = BeautifulSoup(r.text, "html.parser")
        results = soup.select(".entry_list a")[:10]

        if not results:
            return []

        # —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        for r_item in results:
            if r_item.get_text(strip=True).lower() == query.lower():
                link = cfg.KYM_BASE_URL + r_item["href"]
                page = session.get(link, headers=cfg.HEADERS, timeout=20)
                soup_page = BeautifulSoup(page.text, "html.parser")
                summary_block = soup_page.select_one(".bodycopy")
                summary_text = clean_text(summary_block)[:cfg.MAX_TEXT_LENGTH] + "..." if summary_block else "–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ."
                title = soup_page.select_one("h1")
                title_text = title.get_text(strip=True) if title else "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
                return f"üìñ <b>{title_text}</b>\n{summary_text}\n\nüîó <a href='{link}'>–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ —Å–∞–π—Ç–µ</a>"

        # –ø–æ–¥—Å–∫–∞–∑–∫–∏ —Å —Ñ–∏–ª—å—Ç—Ä–æ–º –ø–æ —Å—Ö–æ–∂–µ—Å—Ç–∏
        suggestions = [{"title": r.get_text(strip=True), "href": r["href"]} for r in results]
        suggestions = [s for s in suggestions if similar(s["title"], query) >= 0.4]
        suggestions.sort(key=lambda s: similar(s["title"], query), reverse=True)
        return suggestions

    except Exception:
        return None

def search_memepedia(query: str, lang="ru"):
    try:
        url = cfg.MEMEPEDIA_SEARCH_URL.format(query=query)
        time.sleep(1)
        r = session.get(url, headers=cfg.HEADERS, timeout=20)
        soup = BeautifulSoup(r.text, "html.parser")
        results = soup.select(".entry-title a")[:10]

        if not results:
            return "‚ùå –ú–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ Memepedia."

        # —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        for r_item in results:
            if r_item.get_text(strip=True).lower() == query.lower():
                link = r_item["href"]
                page = session.get(link, headers=cfg.HEADERS, timeout=20)
                soup_page = BeautifulSoup(page.text, "html.parser")
                content_block = soup_page.select_one(".entry-content")
                summary_text = clean_text(content_block)[:cfg.MAX_TEXT_LENGTH] + "..." if content_block else "–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ."
                title = soup_page.select_one("h1")
                title_text = title.get_text(strip=True) if title else "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
                return f"üìñ <b>{title_text}</b>\n{summary_text}\n\nüîó <a href='{link}'>–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ —Å–∞–π—Ç–µ</a>"

        # –ø–æ–¥—Å–∫–∞–∑–∫–∏
        suggestions = [{"title": r.get_text(strip=True), "href": r["href"]} for r in results]
        suggestions = [s for s in suggestions if similar(s["title"], query) >= 0.4]
        suggestions.sort(key=lambda s: similar(s["title"], query), reverse=True)
        return suggestions

    except Exception:
        return "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Memepedia."

# === –•–ï–ù–î–õ–ï–†–´ ===
@bot.on_message(filters.command("start") | button_filter(buttons.back_button))
async def start_command(_, message: Message):
    await message.reply(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –º–µ–º–æ–≤.\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "<b>/time</b> ‚Äì —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è ‚è∞\n"
        "<b>/meme_en &lt;–Ω–∞–∑–≤–∞–Ω–∏–µ&gt;</b> ‚Äì –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –º–µ–º üá∫üá∏\n"
        "<b>/meme_ru &lt;–Ω–∞–∑–≤–∞–Ω–∏–µ&gt;</b> ‚Äì —Ä—É—Å—Å–∫–∏–π –º–µ–º üá∑üá∫\n",
        reply_markup=keyboards.main_keyboard,
        parse_mode=ParseMode.HTML
    )

@bot.on_message(filters.command("time") | button_filter(buttons.time_button))
async def time_command(_, message: Message):
    current_time = time.strftime("%H:%M:%S")
    await message.reply(f"‚è∞ –°–µ–π—á–∞—Å: <b>{current_time}</b>", reply_markup=keyboards.main_keyboard, parse_mode=ParseMode.HTML)

# === –ö–ù–û–ü–ö–ò –ú–ï–ú–û–í ===
@bot.on_message(button_filter(buttons.meme_en_button))
async def meme_en_button(_, message: Message):
    user_state[message.from_user.id] = {"lang": "en"}
    await message.reply("‚úçÔ∏è –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–Ω–≥–ª–æ—è–∑—ã—á–Ω–æ–≥–æ –º–µ–º–∞:", parse_mode=ParseMode.HTML)

@bot.on_message(button_filter(buttons.meme_ru_button))
async def meme_ru_button(_, message: Message):
    user_state[message.from_user.id] = {"lang": "ru"}
    await message.reply("‚úçÔ∏è –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä—É—Å—Å–∫–æ–≥–æ –º–µ–º–∞:", parse_mode=ParseMode.HTML)

# === –û–ë–†–ê–ë–û–¢–ö–ê –í–í–û–î–ê –ú–ï–ú–ê ===
@bot.on_message()
async def handle_meme_text(_, message: Message):
    uid = message.from_user.id
    if uid not in user_state:
        return

    state = user_state[uid]
    query = message.text.strip()
    await message.reply("‚è≥ –ò—â—É –º–µ–º...")

    if "suggestions" in state:
        for s in state["suggestions"]:
            if s["title"].lower() == query.lower():
                link = cfg.KYM_BASE_URL + s["href"] if state["lang"] == "en" else s["href"]
                page = session.get(link, headers=cfg.HEADERS, timeout=20)
                soup_page = BeautifulSoup(page.text, "html.parser")
                content_block = soup_page.select_one(".bodycopy" if state["lang"] == "en" else ".entry-content")
                summary_text = clean_text(content_block)[:cfg.MAX_TEXT_LENGTH] + "..." if content_block else "–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ."
                title = soup_page.select_one("h1")
                title_text = title.get_text(strip=True) if title else "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"

                await message.reply(f"üìñ <b>{title_text}</b>\n{summary_text}\n\nüîó <a href='{link}'>–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ —Å–∞–π—Ç–µ</a>", parse_mode=ParseMode.HTML)
                user_state.pop(uid)
                return

        await message.reply("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.")
        return

    # –ü–æ–∏—Å–∫ –∞–Ω–≥–ª–∏–π—Å–∫–∏—Ö –º–µ–º–æ–≤ —Å–Ω–∞—á–∞–ª–∞ –Ω–∞ KYM
    if state["lang"] == "en":
        result = search_kym(query)
        if result is None or result == []:  # KYM –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –∏–ª–∏ –Ω–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π ‚Üí Memepedia EN
            result = search_memepedia(query, lang="en")
    else:
        result = search_memepedia(query, lang="ru")

    if isinstance(result, list):
        user_state[uid]["suggestions"] = result
        suggest_text = "\n".join([f"- {s['title']}" for s in result])
        await message.reply(f"ü§î –ú–æ–∂–µ—Ç –±—ã—Ç—å, –≤—ã –∏–º–µ–ª–∏ –≤ –≤–∏–¥—É:\n{suggest_text}", parse_mode=ParseMode.HTML)
    else:
        await message.reply(result, parse_mode=ParseMode.HTML)
        user_state.pop(uid)

# === –ó–ê–ü–£–°–ö ===
if __name__ == "__main__":
    print("[LOG] –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    bot.run()
